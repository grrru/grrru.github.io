## 🎯 배열 선언
- 원소의 개수, 원소 타입으로 선언하며 별도의 초기값을 지정하지 않는 경우 타입 기본값으로 초기화된다
	```go
	var nums [5]int // [0, 0, 0, 0, 0]
	var temps [3]float64 = [3]float64{24.3, 11.1} // [24.3, 11.1, 0.0]
	```
- 인덱스를 정하여 원소를 초기화할 수 있다
	```go
	var s = [5]int{1:10, 3:30} // [0, 10, 0 ,30, 0]
        ```

- `...`를 사용해 배열 요소 개수를 생략할 수 있으며, 이 때 배열 요소 개수는 초기화되는 요소 개수와 같다
	```go
	x := [...]{10, 20, 30}
> 💡 배열 길이는 반드시 상수로 선언해야 한다
>` not-constant array bound x`

## 🎯 배열 요소 접근
```go
nums[2] = 300
for i := 0; i < len(nums); i++ {
	fmt.Println(nums[i])
}
```
- 대괄호 인덱스를 통해 요소에 접근한다
- len() 함수는 배열 길이를 반환한다

### 📌 range 순회
```go
for i, v := range arr {
	fmt.Println(v) // declared and not used: icompiler[UnusedVar]
}

for _, v := range arr {
	fmt.Println(v)
}

```
- for 문에서 `range`키워드를 이용하여 인덱스와 배열 요소를 순회할 수 있다
- 사용하지 않는 변수는 `_`로 무효화해야 한다

## 🎯 배열은 연속된 메모리
```go
arr := [...]int{4, 2, 3}

fmt.Printf("%p\n", &arr)        // 0x140000140f0
fmt.Printf("%p\n", &arr[0])     // 0x140000140f0

// 요소 위치 = 배열 시작 주소 + (인덱스 X 타입 크기)
```
- 배열 a는 메모리 공간의 연속된 위치에 요소들을 저장하며 컴퓨터는 인덱스와 타입 크기를 사용해서 메모리 주소를 찾는다

### 📌 배열 복사
```go
arr := [...]int{4, 2, 3}
brr := [3]int{100, 100, 100}

fmt.Printf("arr = %p\n", &arr) // arr = 0x14000116018
fmt.Printf("brr = %p\n", &brr) // brr = 0x14000116030

brr = arr

fmt.Printf("brr = %p\n", &brr) // brr = 0x14000116030
```
- Go언에에서 대입 연산자는 우변의 값을 좌변의 메모리 공간에 복사한다. 이 때 복사되는 크기는 타입 크기와 같다.

## 🎯 다중배열
```go
var b = [2][5]int{
	{1, 2, 3, 4, 5},
	{1, 2, 3, 4, 5}, // 쉼표 찍어야 함
}

var a = [2][2]int{{1, 2}, {3, 4}}
```
- 다중 배열 초기화 시 중괄호가 마지막 요소와 같은 줄에 있지 않은 경우 쉼표를 찍어야 한다