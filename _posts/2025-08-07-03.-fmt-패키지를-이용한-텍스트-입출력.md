---
title: "03. fmt 패키지를 이용한 텍스트 입출력"
date: 2025-08-07 18:02 +0900
categories:
  - Golang
tags:
  - fmt
pin: false
---
## 🎯 표준 입출력

- Print() : 함수 입력값들을 출력한다
- Println() : 함수 입력값들을 출력하고 개행한다
- Printf() : 서식(format)에 맞도록 입력값들을 출력한다

### 📌 서식 문자

- Printf() 함수는 다음과 같은 형식으로 사용한다
    
    ```go
    Printf(서식 문자열, 인수1, 인수2, ...)
    ```
    
- 서식 지정자
    
    
    | **서식** | **의미** | **예시 출력** |
    | --- | --- | --- |
    | %d | 10진수 정수 | 42 |
    | %b | 2진수 정수 | 101010 |
    | %c | 유니코드 문자(정수 타입만 가능) | 'A' |
    | %f | 실숫값 그대로 출력 | 123.456 |
    | %e | 지수 형태로 실숫값 출력 | 1.23e+78 |
    | %g | 값이 크면 지수 형태, 작으면 실수 그대로 출력 |  |
    | %s | 문자열 출력 | “hello” |
    | %q | 특수 문자도 그대로 출력 | “hello\n” |
    | %p | 메모리 주소값 출력 | 0x1400011200c |
- 최소 출력 너비 지정
    - %와 타입 사이에 숫자를 넣어 최소 너비를 지정할 수 있다 `%5d`
    - 너비 앞에 0을 붙이면 빈자리를 0으로 채운다 `%05d`
    - 마이너스 `-`를 붙이면 왼쪽을 기준 삼아 출력한다 `-5d`
    - 최소 너비보다 긴 값을 출력하면 최소 너비가 무시되어 출력된다
    
    ```go
    	var a int = -123
    	fmt.Printf("%5d\n%05d\n%-5d\n", a, a, a)
    	
    /*
     -123
    -0123
    -123 
    */
    ```
    
    - f 서식의 점 뒤 숫자는 표현되는 소숫점 개수를 의미한다 `%08.2f`
    - g서식의 점 뒤 숫자는 표현되는 숫자의 개수를 의미한다 `%08.2g`
    - `%f`는 기본적으로 소숫점 이하 숫자 6개가 표현된다
    
    ```go
    	var a = 324.12345
    	fmt.Printf("%08.2f\n", a)
    	fmt.Printf("%08.2g\n", a)
    	fmt.Printf("%f\n", a)
    /*	
    00324.12
    03.2e+02
    324.123450
    */
    ```
    

### 📌 특수문자

- `\n` `\t` `\\` `\"`

## 🎯 표준 입력

### 📌 Scan(), Scanln()

- 변수들의 메모리 주소를 인수로 받으며 리턴값은 입력한 값 개수와 실패 시 에러이다
- Scanln()은 Enter가 입력되면 입력을 멈춘다

```go
	n, err := fmt.Scan(&a, &b)
	// n, err := fmt.Scanln(&a, &b)

	if err != nil {
		fmt.Println(n, err)
	} else {
		fmt.Println(n, a, b)
	}
```

### 📌 Scanf()

- 서식에 맞는 입력을 받는다
- 서식은 출력 서식과 다르게 `%f`, `%d`, `%s`, `%v`와 같은 입력 타입 식별자만 사용한다

```go
	var c float32
	n, err := fmt.Scan(&a, &b)
	fmt.Scanf("%f", &c)
```

## 🎯 표준 입력 스트림

- 표준 입력 장치로 입력하면 컴퓨텨 내부에 표준 입력 스트림이라는 메모리 공간에 임시 저장되며, Scan 함수들이 표준 입력 스트림에서 값을 읽어서 입력값을 처리한다
- 표준 입력 스트림은 FIFO 구조를 가진다
- 입력을 받는 도중 에러 발생 시 표준 입력 스트림에 데이터가 남아있는 경우, 다음 Scan이 호출되면 입력을 새로 받는 것이 아닌 기존에 남아있는 표준 입력 스트림에서 값을 가져오게 된다
    
    ```go
    	n, err := fmt.Scan(&a, &b)
    	fmt.Scan(&s)
    
    	fmt.Println("s = ", s)
    	
    	// 2 go 입력
    	// s = o 출력
    
    ```
    
- 따라서 여러 번 Scan 함수를 호출할 경우, 에러 시 표준 입력 스트림을 지워주어야 한다
    
    ```go
    stdin := bufio.NewReader(os.Stdin)
    
    if err != nil {
    	stdin.ReadString('\n') // 표준 입력 스트림 지우기
    }
    ```