
[{"content":"","date":"28 December 2025","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"28 December 2025","externalUrl":null,"permalink":"/authors/grrru/","section":"Authors","summary":"","title":"Grrru","type":"authors"},{"content":"","date":"28 December 2025","externalUrl":null,"permalink":"/","section":"grrru blog","summary":"","title":"grrru blog","type":"page"},{"content":" OverTheWire Bandit # OverTheWire: Bandit\n리눅스 연습!\n각 단계에서 얻은 password로 다음 레벨의 아이디(e.g. bandit1)에 접속할 수 있다.\nlevel 0 # ssh를 이용해서 bandit0 유저로bandit.labs.overthewire.org:2220에 접속하면 된다.\nssh bandit.labs.overthewire.org -p 2220 -l bandit0 ssh bandit10@bandit.labs.overthewire.org -p 2220 ## host 앞에 user@를 붙이는 것도 가능하다 home directory에 있는 readme라는 파일을 읽어 bandit1의 password를 찾아낸다. 찾아낸 password는 로컬 머신에 복사해둬야 한다.\ncat ~/readme level 1 # home directory의 - 파일(dashed file)을 읽어야 한다. (ls -al로 home directory의 파일들을 확인)\n-라는 이름의 파일은 cat -로 바로 읽게 되면 아무 반응이 없는데, -가 표준 입력 stdin을 의미해서 입력을 기다리는 상태가 되기 때문이다.\nbandit1@bandit:~$ cat - hello hello 아래와 같이 읽을 수 있다.\ncat \u0026lt; - ## dashed file을 읽어 stdin으로 연결 cat ./- ## dashed file의 위치를 지정하여 읽음 level 2 # 파일명에 공백이 있는 파일을 읽어야 한다. 공백 앞에 \\를 붙여야 읽을 수 있다.\ncat ./--spaces\\ in\\ this\\ filename-- level 3 # ~/inhere 디렉토리의 숨은 파일을 읽어야 한다. ls는 숨은 파일은 알려주지 않으므로 ls -a를 사용해야 한다.\nls -al ## a: all l: long-listing cat ./...Hiding-From-You 나는 주로 ls -al을 사용하는데, l 옵션은 권한, 소유자, 그룹, 크기, 시간 등을 한 줄씩 출력해줘서 읽기 편한듯,,\nlevel 4 # human-readable 파일을 읽어야 한다. file 커맨드로 파일의 MIME 타입 등의 정보를 알 수 있다.\ncd ~/inhere file -i ./* 파일 하나만 ASCII text으로 사람이 읽을 수 있다.\nlevel 5 # inhere 디렉토리에서 아래 조건을 만족하는 파일을 찾아서 읽어야 한다.\n- human-readable - 1033 bytes in size - not executable find .는 현재 디렉토리 하위의 모든 파일과 디렉토리들을 보여준다.\nfind . -type f -size 1033c ! -executable -type: 검색할 타입을 지정한다.\n\btype 의미 f 일반 파일 d 디렉토리 l 심볼릭 링크 c 문자 디바이스 b 블록 디바이스 p 파이프(FIFO) s 소켓 -size: 사이즈로 검색한다.\n\bsize 의미 c bytes b 512-byte blocks k kilobytes (1024B) M megabytes G gigabytes -executable: 실행 가능한 것을 의미하며 앞에 !을 붙여 부정으로 바꿀 수 있다. level 6 # server 내의 어딘가에 있는 파일 중 아래 조건을 만족하는 파일을 읽어야 한다.\nowned by user bandit7 owned by group bandit6 33 bytes in size find / -type f -size 33c -user bandit7 -group bandit6 2\u0026gt;/dev/null -user, -group로 owner 검색이 가능하다. 2\u0026gt;/dev/null를 쓰지 않으면 find 커맨드 실행 중 권한이 없는 디렉토리/파일을 만날 때 에러 메시지 Permission Denied를 stderr(FD 2)로 출력한다. 2\u0026gt;/dev/null은 sderr 2를 /dev/null로 리다이렉션(\u0026gt;)하여 에러 출력이 버려지도록 한다.\nlevel 7 # 겁나 큰 용량의 data.txt 파일 내에서 millionth라는 단어의 옆에 써있는 password를 읽어야 한다.\nls -lh ## h: human 옵션으로 용량 값을 읽기 쉽도록 바꿔준다. cat data.txt | grep millionth level 8 # data.txt 에서 유일한 line을 찾아야 한다.\nsort data.txt | uniq -iu sort로 파일의 line들을 정렬한다. 여러 옵션을 추가로 사용할 수 있다. uniq 커맨드는 중복되는 line을 제거하고 출력해준다. -d는 중복된 내용만 출력, -u는 고유한 내용만 출력, -i는 대소문자 구분 무시 옵션이다.\nlevel 9 # data.txt에서 읽을 수 있는, =가 앞에 있는 문자열만을 출력해야 한다.\nfile data.txt ## data.txt: data strings data.txt | grep \u0026#39;=\u0026#39; strings는 파일에 포함된 string을 뽑아낼 수 있다.\nlevel 10 # base64 인코딩된 문자열이 data.txt에 들어있다.\ncat data.txt | base64 -d base64 -d 커맨드로 문자열을 디코딩하여 원래 바이너리를 출력한다.\nlevel 11 # 시저 암호가 적용된 data.txt 파일을 해석해야 한다. Rot13이므로 A → N Z→ M으로 치환한다.\n정규식은 아니라고 한다.. (tr에서 쓰인 규칙일 뿐)\ncat data.txt | tr \u0026#39;[A-Za-z]\u0026#39; \u0026#39;[N-ZA-Mn-za-m]\u0026#39; ","date":"28 December 2025","externalUrl":null,"permalink":"/posts/overthewire-bandit-level-0-~-level-11/","section":"Posts","summary":"","title":"OverTheWire Bandit(1)","type":"posts"},{"content":"","date":"28 December 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"17 December 2025","externalUrl":null,"permalink":"/authors/chatgpt/","section":"Authors","summary":"","title":"ChatGPT","type":"authors"},{"content":"프로그래밍 언어를 분류할 때 흔히 “컴파일 언어”, “인터프리터 언어”라는 표현을 사용한다. 하지만 실제 실행 과정을 들여다보면 이 구분은 꽤 단순화된 표현이다. 이 글에서는 Java, Go, Python이 각각 어떤 단계로 코드가 실행되는지를 중심으로 정리한다.\n1. Java의 실행 과정 # Java는 전통적으로 컴파일 언어라고 불린다. 이때 말하는 컴파일은 소스 코드에서 바로 기계어로 변환하는 것이 아니라, 바이트코드로 변환하는 단계를 의미한다.\n실행 흐름 # Java 소스 코드 (.java) ↓ javac (컴파일) Java 바이트코드 (.class) ↓ JVM (Java Virtual Machine) ├─ 인터프리터 실행 └─ JIT 컴파일 → 기계어 실행 특징 # javac는 소스를 정적 타입 검사 후 바이트코드로 컴파일한다. JVM은 바이트코드를 바로 CPU에서 실행하지 않는다. 처음에는 인터프리터로 실행하다가, 자주 실행되는 메서드나 루프를 JIT 컴파일해 기계어로 변환한다. JVM 자체는 이미 기계어로 컴파일된 프로그램이다. 정리 # Java는 컴파일 언어이면서 동시에 VM + JIT 기반 언어다.\n2. Go의 실행 과정 # Go는 비교적 전통적인 의미에 가까운 컴파일 언어다. 실행 전에 완전한 네이티브 바이너리를 만든다.\n실행 흐름 # Go 소스 코드 (.go) ↓ go build / go run 기계어 바이너리 ↓ CPU에서 직접 실행 특징 # 컴파일 시점에 모든 코드가 기계어로 변환된다. 실행 시점에 VM이나 바이트코드 단계가 없다. 런타임은 포함되지만(스케줄러, GC), 해석(interpreter) 단계는 없다. 실행 성능과 예측 가능성이 높다. 정리 # Go는 정적 컴파일 → 직접 실행 구조를 가진 언어다.\n3. Python(CPython)의 실행 과정 # Python은 흔히 인터프리터 언어라고 불린다. 하지만 내부적으로는 바이트코드 단계를 거친다.\n실행 흐름 (CPython 기준) # Python 소스 코드 (.py) ↓ 파싱 Python 바이트코드 (.pyc) ↓ Python VM(인터프리터)가 바이트코드 실행 특징 # 실행 전에 소스 코드를 바이트코드로 변환한다. 이 바이트코드는 CPU용 기계어가 아니라 Python VM 전용 명령어다. Python VM은 이미 기계어로 컴파일된 프로그램이다. 바이트코드는 인터프리터가 명령어 단위로 하나씩 실행한다. 기본 CPython에는 JIT이 없다. 정리 # Python은 바이트코드를 인터프리터가 실행하는 언어다.\n4. Python(PyPy)의 실행 과정 # PyPy는 Python을 실행하는 다른 구현체다. CPython과 달리 JIT 컴파일러를 포함한다.\n실행 흐름 # Python 소스 코드 ↓ 바이트코드 / 내부 표현 ↓ PyPy VM ├─ 인터프리터 실행 └─ JIT 컴파일 → 기계어 실행 특징 # 처음에는 인터프리터 방식으로 실행한다. 반복적으로 실행되는 코드 경로를 감지한다. 그 경로를 JIT 컴파일해 기계어로 직접 실행한다. “구문 단위”가 아니라 실행 경로 단위로 컴파일한다. 정리 # PyPy는 인터프리터 + JIT 하이브리드 구조를 가진 Python 구현체다.\n5. 한눈에 비교 # 언어 중간 바이트코드 VM JIT 실행 방식 Java 있음 (.class) 있음 (JVM) 있음 인터프리터 + JIT Go 없음 없음 없음 네이티브 직접 실행 Python(CPython) 있음 (.pyc) 있음 없음 인터프리터 Python(PyPy) 있음 있음 있음 인터프리터 + JIT 6. 결론 # “컴파일 언어 vs 인터프리터 언어”라는 구분은 실제 구현을 단순화한 표현이다. Java와 PyPy는 모두 VM 위에서 인터프리터 + JIT 구조를 사용한다. Go는 실행 전에 모든 것을 결정하는 전통적인 컴파일 모델에 가깝다. Python은 구현체에 따라 실행 모델이 달라질 수 있다. 중요한 것은 언어의 이름이 아니라, 어떤 실행 모델을 선택하느냐다.\n","date":"17 December 2025","externalUrl":null,"permalink":"/posts/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95/","section":"Posts","summary":"","title":"컴파일·인터프리터 실행 과정","type":"posts"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]