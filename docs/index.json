
[{"content":"","date":"17 December 2025","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"17 December 2025","externalUrl":null,"permalink":"/authors/chatgpt/","section":"Authors","summary":"","title":"ChatGPT","type":"authors"},{"content":"","date":"17 December 2025","externalUrl":null,"permalink":"/","section":"grrru","summary":"","title":"grrru","type":"page"},{"content":"","date":"17 December 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"프로그래밍 언어를 분류할 때 흔히 “컴파일 언어”, “인터프리터 언어”라는 표현을 사용한다. 하지만 실제 실행 과정을 들여다보면 이 구분은 꽤 단순화된 표현이다. 이 글에서는 Java, Go, Python이 각각 어떤 단계로 코드가 실행되는지를 중심으로 정리한다.\n1. Java의 실행 과정 # Java는 전통적으로 컴파일 언어라고 불린다. 이때 말하는 컴파일은 소스 코드에서 바로 기계어로 변환하는 것이 아니라, 바이트코드로 변환하는 단계를 의미한다.\n실행 흐름 # Java 소스 코드 (.java) ↓ javac (컴파일) Java 바이트코드 (.class) ↓ JVM (Java Virtual Machine) ├─ 인터프리터 실행 └─ JIT 컴파일 → 기계어 실행 특징 # javac는 소스를 정적 타입 검사 후 바이트코드로 컴파일한다. JVM은 바이트코드를 바로 CPU에서 실행하지 않는다. 처음에는 인터프리터로 실행하다가, 자주 실행되는 메서드나 루프를 JIT 컴파일해 기계어로 변환한다. JVM 자체는 이미 기계어로 컴파일된 프로그램이다. 정리 # Java는 컴파일 언어이면서 동시에 VM + JIT 기반 언어다.\n2. Go의 실행 과정 # Go는 비교적 전통적인 의미에 가까운 컴파일 언어다. 실행 전에 완전한 네이티브 바이너리를 만든다.\n실행 흐름 # Go 소스 코드 (.go) ↓ go build / go run 기계어 바이너리 ↓ CPU에서 직접 실행 특징 # 컴파일 시점에 모든 코드가 기계어로 변환된다. 실행 시점에 VM이나 바이트코드 단계가 없다. 런타임은 포함되지만(스케줄러, GC), 해석(interpreter) 단계는 없다. 실행 성능과 예측 가능성이 높다. 정리 # Go는 정적 컴파일 → 직접 실행 구조를 가진 언어다.\n3. Python(CPython)의 실행 과정 # Python은 흔히 인터프리터 언어라고 불린다. 하지만 내부적으로는 바이트코드 단계를 거친다.\n실행 흐름 (CPython 기준) # Python 소스 코드 (.py) ↓ 파싱 Python 바이트코드 (.pyc) ↓ Python VM(인터프리터)가 바이트코드 실행 특징 # 실행 전에 소스 코드를 바이트코드로 변환한다. 이 바이트코드는 CPU용 기계어가 아니라 Python VM 전용 명령어다. Python VM은 이미 기계어로 컴파일된 프로그램이다. 바이트코드는 인터프리터가 명령어 단위로 하나씩 실행한다. 기본 CPython에는 JIT이 없다. 정리 # Python은 바이트코드를 인터프리터가 실행하는 언어다.\n4. Python(PyPy)의 실행 과정 # PyPy는 Python을 실행하는 다른 구현체다. CPython과 달리 JIT 컴파일러를 포함한다.\n실행 흐름 # Python 소스 코드 ↓ 바이트코드 / 내부 표현 ↓ PyPy VM ├─ 인터프리터 실행 └─ JIT 컴파일 → 기계어 실행 특징 # 처음에는 인터프리터 방식으로 실행한다. 반복적으로 실행되는 코드 경로를 감지한다. 그 경로를 JIT 컴파일해 기계어로 직접 실행한다. “구문 단위”가 아니라 실행 경로 단위로 컴파일한다. 정리 # PyPy는 인터프리터 + JIT 하이브리드 구조를 가진 Python 구현체다.\n5. 한눈에 비교 # 언어 중간 바이트코드 VM JIT 실행 방식 Java 있음 (.class) 있음 (JVM) 있음 인터프리터 + JIT Go 없음 없음 없음 네이티브 직접 실행 Python(CPython) 있음 (.pyc) 있음 없음 인터프리터 Python(PyPy) 있음 있음 있음 인터프리터 + JIT 6. 결론 # “컴파일 언어 vs 인터프리터 언어”라는 구분은 실제 구현을 단순화한 표현이다. Java와 PyPy는 모두 VM 위에서 인터프리터 + JIT 구조를 사용한다. Go는 실행 전에 모든 것을 결정하는 전통적인 컴파일 모델에 가깝다. Python은 구현체에 따라 실행 모델이 달라질 수 있다. 중요한 것은 언어의 이름이 아니라, 어떤 실행 모델을 선택하느냐다.\n","date":"17 December 2025","externalUrl":null,"permalink":"/posts/compile/","section":"Posts","summary":"","title":"컴파일·인터프리터 실행 과정","type":"posts"},{"content":"func main() { fmt.Println(\u0026#34;Hello World\u0026#34;) } ","date":"17 December 2025","externalUrl":null,"permalink":"/posts/test/","section":"Posts","summary":"","title":"컴파일·인터프리터 실행 과정","type":"posts"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]